diff --git a/WORKSPACE b/WORKSPACE
index e4460bfc54..4f2feff1d1 100644
--- a/WORKSPACE
+++ b/WORKSPACE
@@ -1,5 +1,23 @@
 workspace(name = "envoy")
 
+load("@bazel_tools//tools/build_defs/repo:http.bzl", "http_archive")
+
+http_archive(
+    name = "dlfcn-win32",
+    build_file_content = """
+cc_library(
+    name = "dlfcn-win32",
+    srcs = ["src/dlfcn.c"],
+    hdrs = ["src/dlfcn.h"],
+    includes = ["src"],
+    visibility = ["//visibility:public"],
+)
+""",
+    strip_prefix = "dlfcn-win32-1.4.1",
+    url = "https://github.com/dlfcn-win32/dlfcn-win32/archive/refs/tags/v1.4.1.tar.gz",
+    sha256 = "30a9f72bdf674857899eb7e553df1f0d362c5da2a576ae51f886e1171fbdb399",
+)
+
 load("//bazel:api_binding.bzl", "envoy_api_binding")
 
 envoy_api_binding()
diff --git a/bazel/repositories.bzl b/bazel/repositories.bzl
index 465f8f55a0..cd045b0747 100644
--- a/bazel/repositories.bzl
+++ b/bazel/repositories.bzl
@@ -13,6 +13,8 @@ WINDOWS_SKIP_TARGETS = [
     "envoy.filters.http.sxg",
     "envoy.tracers.dynamic_ot",
     "envoy.tracers.datadog",
+    # Only implemented for Linux.
+    "envoy.resource_monitors.cpu_utilization",
     # Extensions that require CEL.
     "envoy.access_loggers.extension_filters.cel",
     "envoy.rate_limit_descriptors.expr",
diff --git a/envoy/api/os_sys_calls.h b/envoy/api/os_sys_calls.h
index 08f2227c4f..bf804eef12 100644
--- a/envoy/api/os_sys_calls.h
+++ b/envoy/api/os_sys_calls.h
@@ -1,6 +1,8 @@
 #pragma once
 
+#ifndef WIN32
 #include <sys/resource.h>
+#endif
 #include <sys/stat.h>
 
 #include <chrono>
@@ -13,6 +15,14 @@
 #include "envoy/common/pure.h"
 #include "envoy/network/address.h"
 
+#ifdef WIN32
+struct rlimit {
+  int rlim_cur;
+  int rlim_max;
+};
+#define RLIMIT_NOFILE 7
+#endif
+
 namespace Envoy {
 namespace Api {
 
diff --git a/envoy/common/platform.h b/envoy/common/platform.h
index 42075f881f..e60f2e02c8 100644
--- a/envoy/common/platform.h
+++ b/envoy/common/platform.h
@@ -69,11 +69,15 @@ typedef DWORD signal_t;            // NOLINT(modernize-use-using)
 
 typedef unsigned int sa_family_t;
 
+
+#ifndef _STRUCT_IOVEC
 // Posix structure for scatter/gather I/O, not present on Windows.
 struct iovec {
   void* iov_base;
   size_t iov_len;
 };
+#define _STRUCT_IOVEC
+#endif  // _STRUCT_IOVEC
 
 // Posix structure for describing messages sent by 'sendmsg` and received by
 // 'recvmsg'
diff --git a/source/common/api/win32/os_sys_calls_impl.cc b/source/common/api/win32/os_sys_calls_impl.cc
index 7fda90aa08..5011ce3d81 100644
--- a/source/common/api/win32/os_sys_calls_impl.cc
+++ b/source/common/api/win32/os_sys_calls_impl.cc
@@ -10,6 +10,14 @@
 
 #define DWORD_MAX UINT32_MAX
 
+#ifndef SIO_SET_RECV_IP_ECN
+#define SIO_SET_RECV_IP_ECN _WSAIOW(IOC_VENDOR, 12)
+#endif
+
+#ifndef SIO_GET_RECV_IP_ECN
+#define SIO_GET_RECV_IP_ECN _WSAIOR(IOC_VENDOR, 13)
+#endif
+
 namespace Envoy {
 namespace Api {
 namespace {
@@ -245,7 +253,10 @@ SysCallIntResult OsSysCallsImpl::fstat(os_fd_t fd, struct stat* buf) {
 SysCallIntResult OsSysCallsImpl::setsockopt(os_fd_t sockfd, int level, int optname,
                                             const void* optval, socklen_t optlen) {
   if (optname == IP_RECVTOS || optname == IPV6_RECVTCLASS) {
-    const int rc = ::WSASetRecvIPEcn(sockfd, *(int*)optval == 1);
+    DWORD enabled = (*(int*)optval == 1) ? TRUE : FALSE;
+    DWORD bytes_returned;
+    const int rc = ::WSAIoctl(sockfd, SIO_SET_RECV_IP_ECN, &enabled, sizeof(enabled), nullptr, 0,
+                              &bytes_returned, nullptr, nullptr);
     return {rc, rc != -1 ? 0 : ::WSAGetLastError()};
   }
   const int rc = ::setsockopt(sockfd, level, optname, static_cast<const char*>(optval), optlen);
@@ -255,7 +266,9 @@ SysCallIntResult OsSysCallsImpl::setsockopt(os_fd_t sockfd, int level, int optna
 SysCallIntResult OsSysCallsImpl::getsockopt(os_fd_t sockfd, int level, int optname, void* optval,
                                             socklen_t* optlen) {
   if (optname == IP_RECVTOS || optname == IPV6_RECVTCLASS) {
-    const int rc = ::WSAGetRecvIPEcn(sockfd, (DWORD*)optval);
+    DWORD bytes_returned;
+    const int rc = ::WSAIoctl(sockfd, SIO_GET_RECV_IP_ECN, nullptr, 0, optval, sizeof(DWORD),
+                              &bytes_returned, nullptr, nullptr);
     return {rc, rc != -1 ? 0 : ::WSAGetLastError()};
   }
   const int rc = ::getsockopt(sockfd, level, optname, static_cast<char*>(optval), optlen);
diff --git a/source/common/common/win32/thread_impl.cc b/source/common/common/win32/thread_impl.cc
index c1beac6a52..21803b910e 100644
--- a/source/common/common/win32/thread_impl.cc
+++ b/source/common/common/win32/thread_impl.cc
@@ -22,9 +22,9 @@ ThreadImplWin32::ThreadImplWin32(std::function<void()> thread_routine, OptionsOp
         return 0;
       },
       this, 0, nullptr));
-  if (options && options.thread_priority_ &&
-      !SetThreadPriority(thread_handle_, *options.thread_priority_)) {
-    ENVOY_LOG_MISC(warn, "Could not set the thread priority to {}", *options.thread_priority_);
+  if (options && options->priority_ &&
+      !SetThreadPriority(thread_handle_, *options->priority_)) {
+    ENVOY_LOG_MISC(warn, "Could not set the thread priority to {}", *options->priority_);
   }
   RELEASE_ASSERT(thread_handle_ != 0, "");
 }
@@ -41,7 +41,7 @@ ThreadPtr ThreadFactoryImplWin32::createThread(std::function<void()> thread_rout
   return std::make_unique<ThreadImplWin32>(thread_routine, options);
 }
 
-ThreadId ThreadFactoryImplWin32::currentThreadId() {
+ThreadId ThreadFactoryImplWin32::currentThreadId() const {
   // TODO(mhoran): test this in windows please.
   return ThreadId(static_cast<int64_t>(::GetCurrentThreadId()));
 }
diff --git a/source/common/common/win32/thread_impl.h b/source/common/common/win32/thread_impl.h
index 87be085291..d40a6b0c6b 100644
--- a/source/common/common/win32/thread_impl.h
+++ b/source/common/common/win32/thread_impl.h
@@ -37,7 +37,7 @@ class ThreadFactoryImplWin32 : public ThreadFactory {
 public:
   // Thread::ThreadFactory
   ThreadPtr createThread(std::function<void()> thread_routine, OptionsOptConstRef options) override;
-  ThreadId currentThreadId() override;
+  ThreadId currentThreadId() const override;
 };
 
 } // namespace Thread
diff --git a/source/extensions/bootstrap/reverse_tunnel/downstream_socket_interface/reverse_connection_address.cc b/source/extensions/bootstrap/reverse_tunnel/downstream_socket_interface/reverse_connection_address.cc
index dcf868020f..0383cb470d 100644
--- a/source/extensions/bootstrap/reverse_tunnel/downstream_socket_interface/reverse_connection_address.cc
+++ b/source/extensions/bootstrap/reverse_tunnel/downstream_socket_interface/reverse_connection_address.cc
@@ -1,8 +1,12 @@
 #include "source/extensions/bootstrap/reverse_tunnel/downstream_socket_interface/reverse_connection_address.h"
 
+#ifndef WIN32
 #include <arpa/inet.h>
 #include <netinet/in.h>
 #include <sys/socket.h>
+#else
+#include <winsock2.h>
+#endif // WIN32
 
 #include <cstring>
 #include <functional>
diff --git a/source/extensions/bootstrap/reverse_tunnel/downstream_socket_interface/reverse_connection_address.h b/source/extensions/bootstrap/reverse_tunnel/downstream_socket_interface/reverse_connection_address.h
index 7d0f78a501..c934a2b793 100644
--- a/source/extensions/bootstrap/reverse_tunnel/downstream_socket_interface/reverse_connection_address.h
+++ b/source/extensions/bootstrap/reverse_tunnel/downstream_socket_interface/reverse_connection_address.h
@@ -1,7 +1,11 @@
 #pragma once
 
+#ifndef WIN32
 #include <netinet/in.h>
 #include <sys/socket.h>
+#else
+#include <winsock2.h>
+#endif // WIN32
 
 #include <functional>
 
diff --git a/source/extensions/common/aws/BUILD b/source/extensions/common/aws/BUILD
index 30efe81fc3..f71a587f67 100644
--- a/source/extensions/common/aws/BUILD
+++ b/source/extensions/common/aws/BUILD
@@ -77,6 +77,7 @@ envoy_cc_library(
     ],
     deps = [
         "//envoy/common:pure_lib",
+        "//envoy/common:time_interface",
         "//source/common/common:cleanup_lib",
         "//source/common/common:lock_guard_lib",
         "//source/common/common:thread_lib",
diff --git a/source/extensions/dynamic_modules/BUILD b/source/extensions/dynamic_modules/BUILD
index dc0b799a35..046015b651 100644
--- a/source/extensions/dynamic_modules/BUILD
+++ b/source/extensions/dynamic_modules/BUILD
@@ -18,7 +18,10 @@ envoy_cc_library(
     deps = [
         ":abi_version_lib",
         "//envoy/common:exception_lib",
-    ],
+    ] + select({
+        "//bazel:windows_x86_64": ["@dlfcn-win32//:dlfcn-win32"],
+        "//conditions:default": [],
+    }),
 )
 
 envoy_cc_library(
diff --git a/source/extensions/dynamic_modules/dynamic_modules.cc b/source/extensions/dynamic_modules/dynamic_modules.cc
index f07d6a23b1..cb1f94878f 100644
--- a/source/extensions/dynamic_modules/dynamic_modules.cc
+++ b/source/extensions/dynamic_modules/dynamic_modules.cc
@@ -1,6 +1,16 @@
 #include "source/extensions/dynamic_modules/dynamic_modules.h"
 
+#ifdef WIN32
+#include "dlfcn.h"
+#ifndef RTLD_NOLOAD
+#define RTLD_NOLOAD 0
+#endif
+#ifndef RTLD_NODELETE
+#define RTLD_NODELETE 0
+#endif
+#else // WIN32
 #include <dlfcn.h>
+#endif // WIN32
 
 #include <string>
 
@@ -25,7 +35,7 @@ newDynamicModule(const std::filesystem::path& object_file_absolute_path, const b
   //
   // So we can use RTLD_NOLOAD to check if the module is already loaded to avoid the duplicate call
   // to the init function.
-  void* handle = dlopen(object_file_absolute_path.c_str(), RTLD_NOLOAD | RTLD_LAZY);
+  void* handle = dlopen(object_file_absolute_path.string().c_str(), RTLD_NOLOAD | RTLD_LAZY);
   if (handle != nullptr) {
     // This means the module is already loaded, and the return value is the handle of the already
     // loaded module. We don't need to call the init function again.
@@ -43,10 +53,10 @@ newDynamicModule(const std::filesystem::path& object_file_absolute_path, const b
   if (do_not_close) {
     mode |= RTLD_NODELETE;
   }
-  handle = dlopen(object_file_absolute_path.c_str(), mode);
+  handle = dlopen(object_file_absolute_path.string().c_str(), mode);
   if (handle == nullptr) {
     return absl::InvalidArgumentError(absl::StrCat(
-        "Failed to load dynamic module: ", object_file_absolute_path.c_str(), " : ", dlerror()));
+        "Failed to load dynamic module: ", object_file_absolute_path.string(), " : ", dlerror()));
   }
 
   DynamicModulePtr dynamic_module = std::make_unique<DynamicModule>(handle);
@@ -62,14 +72,14 @@ newDynamicModule(const std::filesystem::path& object_file_absolute_path, const b
   const char* abi_version = (*init_function.value())();
   if (abi_version == nullptr) {
     return absl::InvalidArgumentError(
-        absl::StrCat("Failed to initialize dynamic module: ", object_file_absolute_path.c_str()));
+        absl::StrCat("Failed to initialize dynamic module: ", object_file_absolute_path.string()));
   }
   // Checks the kAbiVersion and the version of the dynamic module.
   if (absl::string_view(abi_version) != absl::string_view(kAbiVersion)) {
     return absl::InvalidArgumentError(
         absl::StrCat("ABI version mismatch: got ", abi_version, ", but expected ", kAbiVersion));
   }
-  return dynamic_module;
+  return std::move(dynamic_module);
 }
 
 absl::StatusOr<DynamicModulePtr> newDynamicModuleByName(const absl::string_view module_name,
@@ -82,7 +92,11 @@ absl::StatusOr<DynamicModulePtr> newDynamicModuleByName(const absl::string_view
                                                    " is not set"));
   }
   const std::filesystem::path file_path_absolute =
+#ifdef WIN32
+      std::filesystem::absolute(fmt::format("{}/lib{}.dll", module_search_path, module_name));
+#else
       std::filesystem::absolute(fmt::format("{}/lib{}.so", module_search_path, module_name));
+#endif
   return newDynamicModule(file_path_absolute, do_not_close, load_globally);
 }
 
