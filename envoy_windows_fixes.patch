diff --git a/WORKSPACE b/WORKSPACE
index e4460bfc54..4f2feff1d1 100644
--- a/WORKSPACE
+++ b/WORKSPACE
@@ -1,5 +1,23 @@
 workspace(name = "envoy")
 
+load("@bazel_tools//tools/build_defs/repo:http.bzl", "http_archive")
+
+http_archive(
+    name = "dlfcn-win32",
+    build_file_content = """
+cc_library(
+    name = "dlfcn-win32",
+    srcs = ["src/dlfcn.c"],
+    hdrs = ["src/dlfcn.h"],
+    includes = ["src"],
+    visibility = ["//visibility:public"],
+)
+""",
+    strip_prefix = "dlfcn-win32-1.4.1",
+    url = "https://github.com/dlfcn-win32/dlfcn-win32/archive/refs/tags/v1.4.1.tar.gz",
+    sha256 = "30a9f72bdf674857899eb7e553df1f0d362c5da2a576ae51f886e1171fbdb399",
+)
+
 load("//bazel:api_binding.bzl", "envoy_api_binding")
 
 envoy_api_binding()
diff --git a/bazel/envoy_internal.bzl b/bazel/envoy_internal.bzl
index 866a00f280..8552fbec63 100644
--- a/bazel/envoy_internal.bzl
+++ b/bazel/envoy_internal.bzl
@@ -214,7 +214,10 @@ def envoy_exported_symbols_input():
     return [
         "@envoy//bazel:exported_symbols.txt",
         "@envoy//bazel:exported_symbols_apple.txt",
-    ]
+    ] + select({
+        "@envoy//bazel:windows_x86_64": ["//source/extensions/dynamic_modules:dynamic_modules_exports.def"],
+        "//conditions:default": [],
+    })
 
 # Default symbols to be exported.
 def _envoy_default_exported_symbols():
@@ -225,6 +228,9 @@ def _envoy_default_exported_symbols():
         "@envoy//bazel:apple": [
             "-Wl,-exported_symbols_list,$(location @envoy//bazel:exported_symbols_apple.txt)",
         ],
+        "@envoy//bazel:windows_x86_64": [
+            "-DEF:$(location //source/extensions/dynamic_modules:dynamic_modules_exports.def)",
+        ],
         "//conditions:default": [],
     })
 
diff --git a/bazel/foreign_cc/BUILD b/bazel/foreign_cc/BUILD
index dc07b536d3..ddf1f24123 100644
--- a/bazel/foreign_cc/BUILD
+++ b/bazel/foreign_cc/BUILD
@@ -500,6 +500,7 @@ envoy_cmake(
         "CMAKE_C_COMPILER_FORCED": "on",
         "SKIP_BUILD_EXAMPLES": "on",
         "BUILD_SHARED_LIBS": "off",
+        "CMAKE_MSVC_RUNTIME_LIBRARY": "MultiThreaded",
 
         # The following entries are for zlib-ng. Since zlib and zlib-ng are compatible source
         # codes and CMake ignores unknown cache entries, it is fine to combine it into one
@@ -522,6 +523,9 @@ envoy_cmake(
         # Reference: https://github.com/zlib-ng/zlib-ng#advanced-build-options.
         "UNALIGNED_OK": "off",
     },
+    debug_cache_entries = {
+        "CMAKE_MSVC_RUNTIME_LIBRARY": "MultiThreadedDebug",
+    },
     generate_args = [
         "-G",
         "Ninja",
diff --git a/bazel/repositories.bzl b/bazel/repositories.bzl
index 465f8f55a0..cd045b0747 100644
--- a/bazel/repositories.bzl
+++ b/bazel/repositories.bzl
@@ -13,6 +13,8 @@ WINDOWS_SKIP_TARGETS = [
     "envoy.filters.http.sxg",
     "envoy.tracers.dynamic_ot",
     "envoy.tracers.datadog",
+    # Only implemented for Linux.
+    "envoy.resource_monitors.cpu_utilization",
     # Extensions that require CEL.
     "envoy.access_loggers.extension_filters.cel",
     "envoy.rate_limit_descriptors.expr",
diff --git a/envoy/api/os_sys_calls.h b/envoy/api/os_sys_calls.h
index 08f2227c4f..bf804eef12 100644
--- a/envoy/api/os_sys_calls.h
+++ b/envoy/api/os_sys_calls.h
@@ -1,6 +1,8 @@
 #pragma once
 
+#ifndef WIN32
 #include <sys/resource.h>
+#endif
 #include <sys/stat.h>
 
 #include <chrono>
@@ -13,6 +15,14 @@
 #include "envoy/common/pure.h"
 #include "envoy/network/address.h"
 
+#ifdef WIN32
+struct rlimit {
+  int rlim_cur;
+  int rlim_max;
+};
+#define RLIMIT_NOFILE 7
+#endif
+
 namespace Envoy {
 namespace Api {
 
diff --git a/envoy/common/platform.h b/envoy/common/platform.h
index 42075f881f..e60f2e02c8 100644
--- a/envoy/common/platform.h
+++ b/envoy/common/platform.h
@@ -69,11 +69,15 @@ typedef DWORD signal_t;            // NOLINT(modernize-use-using)
 
 typedef unsigned int sa_family_t;
 
+
+#ifndef _STRUCT_IOVEC
 // Posix structure for scatter/gather I/O, not present on Windows.
 struct iovec {
   void* iov_base;
   size_t iov_len;
 };
+#define _STRUCT_IOVEC
+#endif  // _STRUCT_IOVEC
 
 // Posix structure for describing messages sent by 'sendmsg` and received by
 // 'recvmsg'
diff --git a/source/common/api/win32/os_sys_calls_impl.cc b/source/common/api/win32/os_sys_calls_impl.cc
index 7fda90aa08..dc32868f62 100644
--- a/source/common/api/win32/os_sys_calls_impl.cc
+++ b/source/common/api/win32/os_sys_calls_impl.cc
@@ -10,6 +10,14 @@
 
 #define DWORD_MAX UINT32_MAX
 
+#ifndef SIO_SET_RECV_IP_ECN
+#define SIO_SET_RECV_IP_ECN _WSAIOW(IOC_VENDOR, 12)
+#endif
+
+#ifndef SIO_GET_RECV_IP_ECN
+#define SIO_GET_RECV_IP_ECN _WSAIOR(IOC_VENDOR, 13)
+#endif
+
 namespace Envoy {
 namespace Api {
 namespace {
@@ -245,7 +253,10 @@ SysCallIntResult OsSysCallsImpl::fstat(os_fd_t fd, struct stat* buf) {
 SysCallIntResult OsSysCallsImpl::setsockopt(os_fd_t sockfd, int level, int optname,
                                             const void* optval, socklen_t optlen) {
   if (optname == IP_RECVTOS || optname == IPV6_RECVTCLASS) {
-    const int rc = ::WSASetRecvIPEcn(sockfd, *(int*)optval == 1);
+    DWORD enabled = (*(int*)optval == 1) ? 1 : 0;
+    DWORD bytes_returned;
+    const int rc = ::WSAIoctl(sockfd, SIO_SET_RECV_IP_ECN, &enabled, sizeof(enabled), nullptr, 0,
+                              &bytes_returned, nullptr, nullptr);
     return {rc, rc != -1 ? 0 : ::WSAGetLastError()};
   }
   const int rc = ::setsockopt(sockfd, level, optname, static_cast<const char*>(optval), optlen);
@@ -255,7 +266,9 @@ SysCallIntResult OsSysCallsImpl::setsockopt(os_fd_t sockfd, int level, int optna
 SysCallIntResult OsSysCallsImpl::getsockopt(os_fd_t sockfd, int level, int optname, void* optval,
                                             socklen_t* optlen) {
   if (optname == IP_RECVTOS || optname == IPV6_RECVTCLASS) {
-    const int rc = ::WSAGetRecvIPEcn(sockfd, (DWORD*)optval);
+    DWORD bytes_returned;
+    const int rc = ::WSAIoctl(sockfd, SIO_GET_RECV_IP_ECN, nullptr, 0, optval, sizeof(DWORD),
+                              &bytes_returned, nullptr, nullptr);
     return {rc, rc != -1 ? 0 : ::WSAGetLastError()};
   }
   const int rc = ::getsockopt(sockfd, level, optname, static_cast<char*>(optval), optlen);
diff --git a/source/common/common/win32/thread_impl.cc b/source/common/common/win32/thread_impl.cc
index c1beac6a52..21803b910e 100644
--- a/source/common/common/win32/thread_impl.cc
+++ b/source/common/common/win32/thread_impl.cc
@@ -22,9 +22,9 @@ ThreadImplWin32::ThreadImplWin32(std::function<void()> thread_routine, OptionsOp
         return 0;
       },
       this, 0, nullptr));
-  if (options && options.thread_priority_ &&
-      !SetThreadPriority(thread_handle_, *options.thread_priority_)) {
-    ENVOY_LOG_MISC(warn, "Could not set the thread priority to {}", *options.thread_priority_);
+  if (options && options->priority_ &&
+      !SetThreadPriority(thread_handle_, *options->priority_)) {
+    ENVOY_LOG_MISC(warn, "Could not set the thread priority to {}", *options->priority_);
   }
   RELEASE_ASSERT(thread_handle_ != 0, "");
 }
@@ -41,7 +41,7 @@ ThreadPtr ThreadFactoryImplWin32::createThread(std::function<void()> thread_rout
   return std::make_unique<ThreadImplWin32>(thread_routine, options);
 }
 
-ThreadId ThreadFactoryImplWin32::currentThreadId() {
+ThreadId ThreadFactoryImplWin32::currentThreadId() const {
   // TODO(mhoran): test this in windows please.
   return ThreadId(static_cast<int64_t>(::GetCurrentThreadId()));
 }
diff --git a/source/common/common/win32/thread_impl.h b/source/common/common/win32/thread_impl.h
index 87be085291..d40a6b0c6b 100644
--- a/source/common/common/win32/thread_impl.h
+++ b/source/common/common/win32/thread_impl.h
@@ -37,7 +37,7 @@ class ThreadFactoryImplWin32 : public ThreadFactory {
 public:
   // Thread::ThreadFactory
   ThreadPtr createThread(std::function<void()> thread_routine, OptionsOptConstRef options) override;
-  ThreadId currentThreadId() override;
+  ThreadId currentThreadId() const override;
 };
 
 } // namespace Thread
diff --git a/source/common/event/win32/signal_impl.cc b/source/common/event/win32/signal_impl.cc
index 0466ee6b73..8cdc1b2510 100644
--- a/source/common/event/win32/signal_impl.cc
+++ b/source/common/event/win32/signal_impl.cc
@@ -32,9 +32,10 @@ SignalEventImpl::SignalEventImpl(DispatcherImpl& dispatcher, signal_t signal_num
 
   read_handle_->initializeFileEvent(
       dispatcher,
-      [this](uint32_t events) -> void {
+      [this](uint32_t events) -> absl::Status {
         ASSERT(events == Event::FileReadyType::Read);
         cb_();
+        return absl::OkStatus();
       },
       Event::FileTriggerType::Level, Event::FileReadyType::Read);
   eventBridgeHandlersSingleton::get()[signal_num] = write_handle;
diff --git a/source/common/filesystem/win32/watcher_impl.cc b/source/common/filesystem/win32/watcher_impl.cc
index 58905d996d..833d657ac2 100644
--- a/source/common/filesystem/win32/watcher_impl.cc
+++ b/source/common/filesystem/win32/watcher_impl.cc
@@ -22,9 +22,10 @@ WatcherImpl::WatcherImpl(Event::Dispatcher& dispatcher, Filesystem::Instance& fi
 
   read_handle_->initializeFileEvent(
       dispatcher,
-      [this](uint32_t events) -> void {
+      [this](uint32_t events) -> absl::Status {
         ASSERT(events == Event::FileReadyType::Read);
         onDirectoryEvent();
+        return absl::OkStatus();
       },
       Event::FileTriggerType::Level, Event::FileReadyType::Read);
 
@@ -203,7 +204,7 @@ void WatcherImpl::directoryChangeCompletion(DWORD err, DWORD num_bytes, LPOVERLA
       if (watch.file_ == file && (watch.events_ & events)) {
         ENVOY_LOG(debug, "matched callback: file: {}", watcher->wstring_converter_.to_bytes(file));
         const auto cb = watch.cb_;
-        const auto cb_closure = [cb, events]() -> void { cb(events); };
+        const auto cb_closure = [cb, events]() -> void { (void)cb(events); };
         watcher->active_callbacks_.push(cb_closure);
         // write a byte to the other end of the socket that libevent is watching
         // this tells the libevent callback to pull this callback off the active_callbacks_
diff --git a/source/common/memory/aligned_allocator.h b/source/common/memory/aligned_allocator.h
index f45e7f74b2..f715987527 100644
--- a/source/common/memory/aligned_allocator.h
+++ b/source/common/memory/aligned_allocator.h
@@ -45,6 +45,8 @@ public:
       return nullptr;
     }
     return static_cast<T*>(ptr);
+#elif defined(_WIN32)
+    return static_cast<T*>(_aligned_malloc(bytes, Alignment));
 #else
     // Ensure bytes is a multiple of Alignment, which is required by std::aligned_alloc.
     bytes = round_up_to_alignment(bytes);
@@ -56,6 +58,8 @@ public:
     if (p != nullptr) {
 #ifdef ALIGNED_ALLOCATOR_USE_POSIX_MEMALIGN
       free(p);
+#elif defined(_WIN32)
+      _aligned_free(p);
 #else
       std::free(p);
 #endif
diff --git a/source/extensions/bootstrap/reverse_tunnel/downstream_socket_interface/reverse_connection_address.cc b/source/extensions/bootstrap/reverse_tunnel/downstream_socket_interface/reverse_connection_address.cc
index dcf868020f..0383cb470d 100644
--- a/source/extensions/bootstrap/reverse_tunnel/downstream_socket_interface/reverse_connection_address.cc
+++ b/source/extensions/bootstrap/reverse_tunnel/downstream_socket_interface/reverse_connection_address.cc
@@ -1,8 +1,12 @@
 #include "source/extensions/bootstrap/reverse_tunnel/downstream_socket_interface/reverse_connection_address.h"
 
+#ifndef WIN32
 #include <arpa/inet.h>
 #include <netinet/in.h>
 #include <sys/socket.h>
+#else
+#include <winsock2.h>
+#endif // WIN32
 
 #include <cstring>
 #include <functional>
diff --git a/source/extensions/bootstrap/reverse_tunnel/downstream_socket_interface/reverse_connection_address.h b/source/extensions/bootstrap/reverse_tunnel/downstream_socket_interface/reverse_connection_address.h
index 7d0f78a501..c934a2b793 100644
--- a/source/extensions/bootstrap/reverse_tunnel/downstream_socket_interface/reverse_connection_address.h
+++ b/source/extensions/bootstrap/reverse_tunnel/downstream_socket_interface/reverse_connection_address.h
@@ -1,7 +1,11 @@
 #pragma once
 
+#ifndef WIN32
 #include <netinet/in.h>
 #include <sys/socket.h>
+#else
+#include <winsock2.h>
+#endif // WIN32
 
 #include <functional>
 
diff --git a/source/extensions/bootstrap/reverse_tunnel/downstream_socket_interface/reverse_connection_io_handle.cc b/source/extensions/bootstrap/reverse_tunnel/downstream_socket_interface/reverse_connection_io_handle.cc
index b8b5c5fe69..bff4cb4dc6 100644
--- a/source/extensions/bootstrap/reverse_tunnel/downstream_socket_interface/reverse_connection_io_handle.cc
+++ b/source/extensions/bootstrap/reverse_tunnel/downstream_socket_interface/reverse_connection_io_handle.cc
@@ -10,6 +10,7 @@
 #include "envoy/network/connection.h"
 #include "envoy/upstream/cluster_manager.h"
 
+#include "source/common/api/os_sys_calls_impl.h"
 #include "source/common/buffer/buffer_impl.h"
 #include "source/common/common/logger.h"
 #include "source/common/event/real_time_system.h"
@@ -54,13 +55,14 @@ void ReverseConnectionIOHandle::cleanup() {
                  "ReverseConnectionIOHandle: cleaning up trigger pipe; "
                  "trigger_pipe_write_fd_={}, trigger_pipe_read_fd_={}",
                  trigger_pipe_write_fd_, trigger_pipe_read_fd_);
-  if (trigger_pipe_write_fd_ >= 0) {
-    ::close(trigger_pipe_write_fd_);
-    trigger_pipe_write_fd_ = -1;
+  auto& os_sys_calls = Api::OsSysCallsSingleton::get();
+  if (trigger_pipe_write_fd_ != INVALID_SOCKET) {
+    os_sys_calls.close(trigger_pipe_write_fd_);
+    trigger_pipe_write_fd_ = INVALID_SOCKET;
   }
-  if (trigger_pipe_read_fd_ >= 0) {
-    ::close(trigger_pipe_read_fd_);
-    trigger_pipe_read_fd_ = -1;
+  if (trigger_pipe_read_fd_ != INVALID_SOCKET) {
+    os_sys_calls.close(trigger_pipe_read_fd_);
+    trigger_pipe_read_fd_ = INVALID_SOCKET;
   }
 
   // Cancel the retry timer safely.
@@ -162,8 +164,8 @@ void ReverseConnectionIOHandle::initializeFileEvent(Event::Dispatcher& dispatche
 
   // CRITICAL: Replace the monitored FD with pipe read FD
   // This must happen before any event registration.
-  int trigger_fd = getPipeMonitorFd();
-  if (trigger_fd != -1) {
+  os_fd_t trigger_fd = getPipeMonitorFd();
+  if (trigger_fd != INVALID_SOCKET) {
     ENVOY_LOG(info, "Replacing monitored FD from {} to pipe read FD {}", fd_, trigger_fd);
     fd_ = trigger_fd;
   }
@@ -190,7 +192,8 @@ Envoy::Network::IoHandlePtr ReverseConnectionIOHandle::accept(struct sockaddr* a
   ENVOY_LOG(debug, "ReverseConnectionIOHandle: accept() called");
   if (isTriggerPipeReady()) {
     char trigger_byte;
-    ssize_t bytes_read = ::read(trigger_pipe_read_fd_, &trigger_byte, 1);
+    auto& os_sys_calls = Api::OsSysCallsSingleton::get();
+    ssize_t bytes_read = os_sys_calls.recv(trigger_pipe_read_fd_, &trigger_byte, 1, 0).return_value_;
     if (bytes_read == 1) {
       ENVOY_LOG(debug, "ReverseConnectionIOHandle: received trigger, processing connection.");
       // When a connection is established, a byte is written to the trigger_pipe_write_fd_ and the
@@ -365,7 +368,7 @@ void ReverseConnectionIOHandle::onEvent(Network::ConnectionEvent event) {
   ENVOY_LOG(trace, "ReverseConnectionIOHandle: event: {}", static_cast<int>(event));
 }
 
-int ReverseConnectionIOHandle::getPipeMonitorFd() const { return trigger_pipe_read_fd_; }
+os_fd_t ReverseConnectionIOHandle::getPipeMonitorFd() const { return trigger_pipe_read_fd_; }
 
 // Get time source for consistent time operations.
 TimeSource& ReverseConnectionIOHandle::getTimeSource() const {
@@ -1034,30 +1037,34 @@ bool ReverseConnectionIOHandle::initiateOneReverseConnection(const std::string&
 // Trigger pipe used to wake up accept() when a connection is established.
 void ReverseConnectionIOHandle::createTriggerPipe() {
   ENVOY_LOG(debug, "ReverseConnectionIOHandle: Creating trigger pipe for single-byte mechanism");
-  int pipe_fds[2];
-  if (pipe(pipe_fds) == -1) {
-    ENVOY_LOG(error, "Failed to create trigger pipe: {}", errorDetails(errno));
-    trigger_pipe_read_fd_ = -1;
-    trigger_pipe_write_fd_ = -1;
+  os_fd_t pipe_fds[2];
+  auto& os_sys_calls = Api::OsSysCallsSingleton::get();
+#ifdef WIN32
+  // On Windows, we use AF_INET to emulate a pipe with a TCP socket pair.
+  const int domain = AF_INET;
+#else
+  // On POSIX, we use AF_UNIX.
+  const int domain = AF_UNIX;
+#endif
+  auto result = os_sys_calls.socketpair(domain, SOCK_STREAM, 0, pipe_fds);
+  if (result.return_value_ != 0) {
+    ENVOY_LOG(error, "Failed to create trigger pipe: {}", errorDetails(result.errno_));
+    trigger_pipe_read_fd_ = INVALID_SOCKET;
+    trigger_pipe_write_fd_ = INVALID_SOCKET;
     return;
   }
   trigger_pipe_read_fd_ = pipe_fds[0];
   trigger_pipe_write_fd_ = pipe_fds[1];
   // Make both ends non-blocking.
-  int flags = fcntl(trigger_pipe_write_fd_, F_GETFL, 0);
-  if (flags != -1) {
-    fcntl(trigger_pipe_write_fd_, F_SETFL, flags | O_NONBLOCK);
-  }
-  flags = fcntl(trigger_pipe_read_fd_, F_GETFL, 0);
-  if (flags != -1) {
-    fcntl(trigger_pipe_read_fd_, F_SETFL, flags | O_NONBLOCK);
-  }
+  os_sys_calls.setsocketblocking(trigger_pipe_write_fd_, false);
+  os_sys_calls.setsocketblocking(trigger_pipe_read_fd_, false);
+
   ENVOY_LOG(debug, "ReverseConnectionIOHandle: Created trigger pipe: read_fd={}, write_fd={}",
             trigger_pipe_read_fd_, trigger_pipe_write_fd_);
 }
 
 bool ReverseConnectionIOHandle::isTriggerPipeReady() const {
-  return trigger_pipe_read_fd_ != -1 && trigger_pipe_write_fd_ != -1;
+  return trigger_pipe_read_fd_ != INVALID_SOCKET && trigger_pipe_write_fd_ != INVALID_SOCKET;
 }
 
 void ReverseConnectionIOHandle::onConnectionDone(const std::string& error,
@@ -1191,15 +1198,16 @@ void ReverseConnectionIOHandle::onConnectionDone(const std::string& error,
       // Trigger accept mechanism safely.
       if (isTriggerPipeReady()) {
         char trigger_byte = 1;
-        ssize_t bytes_written = ::write(trigger_pipe_write_fd_, &trigger_byte, 1);
-        if (bytes_written == 1) {
+        auto& os_sys_calls = Api::OsSysCallsSingleton::get();
+        auto result = os_sys_calls.send(trigger_pipe_write_fd_, &trigger_byte, 1, 0);
+        if (result.return_value_ == 1) {
           ENVOY_LOG(info,
                     "ReverseConnectionIOHandle: Successfully triggered reverse_conn_listener "
                     "accept() for host {}",
                     host_address);
         } else {
           ENVOY_LOG(error, "ReverseConnectionIOHandle: Failed to write trigger byte: {}",
-                    errorDetails(errno));
+                    errorDetails(result.errno_));
         }
       }
     }
diff --git a/source/extensions/bootstrap/reverse_tunnel/downstream_socket_interface/reverse_connection_io_handle.h b/source/extensions/bootstrap/reverse_tunnel/downstream_socket_interface/reverse_connection_io_handle.h
index 48adcd3de5..b87dd85836 100644
--- a/source/extensions/bootstrap/reverse_tunnel/downstream_socket_interface/reverse_connection_io_handle.h
+++ b/source/extensions/bootstrap/reverse_tunnel/downstream_socket_interface/reverse_connection_io_handle.h
@@ -205,7 +205,7 @@ public:
    * Get the file descriptor for the pipe monitor used to wake up accept().
    * @return the file descriptor for the pipe monitor
    */
-  int getPipeMonitorFd() const;
+  os_fd_t getPipeMonitorFd() const;
 
   // Callbacks from RCConnectionWrapper.
   /**
@@ -406,8 +406,8 @@ private:
 
   // Simple pipe-based trigger mechanism to wake up accept() when a connection is established.
   // Inlined directly for simplicity and reduced test coverage requirements.
-  int trigger_pipe_read_fd_{-1};
-  int trigger_pipe_write_fd_{-1};
+  os_fd_t trigger_pipe_read_fd_{INVALID_SOCKET};
+  os_fd_t trigger_pipe_write_fd_{INVALID_SOCKET};
 
   // Connection management : We store the established connections in a queue
   // and pop the last established connection when data is read on trigger_pipe_read_fd_
@@ -422,7 +422,7 @@ private:
   Event::Dispatcher* worker_dispatcher_{nullptr}; // Dispatcher for the worker thread
 
   // Store original socket FD for cleanup.
-  os_fd_t original_socket_fd_{-1};
+  os_fd_t original_socket_fd_{static_cast<os_fd_t>(-1)};
 };
 
 } // namespace ReverseConnection
diff --git a/source/extensions/bootstrap/reverse_tunnel/upstream_socket_interface/reverse_tunnel_acceptor.h b/source/extensions/bootstrap/reverse_tunnel/upstream_socket_interface/reverse_tunnel_acceptor.h
index b543752543..fdb98e0624 100644
--- a/source/extensions/bootstrap/reverse_tunnel/upstream_socket_interface/reverse_tunnel_acceptor.h
+++ b/source/extensions/bootstrap/reverse_tunnel/upstream_socket_interface/reverse_tunnel_acceptor.h
@@ -1,7 +1,5 @@
 #pragma once
 
-#include <unistd.h>
-
 #include <atomic>
 #include <cstdint>
 
diff --git a/source/extensions/bootstrap/reverse_tunnel/upstream_socket_interface/reverse_tunnel_acceptor_extension.h b/source/extensions/bootstrap/reverse_tunnel/upstream_socket_interface/reverse_tunnel_acceptor_extension.h
index 2f16d81f8c..15ab6d45ce 100644
--- a/source/extensions/bootstrap/reverse_tunnel/upstream_socket_interface/reverse_tunnel_acceptor_extension.h
+++ b/source/extensions/bootstrap/reverse_tunnel/upstream_socket_interface/reverse_tunnel_acceptor_extension.h
@@ -1,7 +1,5 @@
 #pragma once
 
-#include <unistd.h>
-
 #include <atomic>
 #include <cstdint>
 
diff --git a/source/extensions/bootstrap/reverse_tunnel/upstream_socket_interface/upstream_socket_manager.cc b/source/extensions/bootstrap/reverse_tunnel/upstream_socket_interface/upstream_socket_manager.cc
index 54654c0be0..7cfbcb9489 100644
--- a/source/extensions/bootstrap/reverse_tunnel/upstream_socket_interface/upstream_socket_manager.cc
+++ b/source/extensions/bootstrap/reverse_tunnel/upstream_socket_interface/upstream_socket_manager.cc
@@ -210,7 +210,11 @@ void UpstreamSocketManager::markSocketDead(const int fd) {
     if (fd == itr->get()->ioHandle().fdDoNotUse()) {
       ENVOY_LOG(debug, "UpstreamSocketManager: marking socket dead. node: {} cluster: {} fd: {}.",
                 node_id, cluster_id, fd);
+#ifndef _WIN32
       ::shutdown(fd, SHUT_RDWR);
+#else
+      ::shutdown(fd, SD_BOTH);
+#endif // _WIN32
       itr = sockets.erase(itr);
       socket_found = true;
 
diff --git a/source/extensions/bootstrap/reverse_tunnel/upstream_socket_interface/upstream_socket_manager.h b/source/extensions/bootstrap/reverse_tunnel/upstream_socket_interface/upstream_socket_manager.h
index 05e34f7933..d333caff75 100644
--- a/source/extensions/bootstrap/reverse_tunnel/upstream_socket_interface/upstream_socket_manager.h
+++ b/source/extensions/bootstrap/reverse_tunnel/upstream_socket_interface/upstream_socket_manager.h
@@ -1,7 +1,5 @@
 #pragma once
 
-#include <unistd.h>
-
 #include <atomic>
 #include <cstdint>
 #include <list>
diff --git a/source/extensions/clusters/reverse_connection/reverse_connection.h b/source/extensions/clusters/reverse_connection/reverse_connection.h
index 3241cab9ad..abee5c8080 100644
--- a/source/extensions/clusters/reverse_connection/reverse_connection.h
+++ b/source/extensions/clusters/reverse_connection/reverse_connection.h
@@ -1,7 +1,11 @@
 #pragma once
 
+#ifndef _WIN32
 #include <netinet/in.h>
 #include <sys/socket.h>
+#else
+#include <winsock2.h>
+#endif // WIN32
 
 #include <cstdint>
 #include <cstring>
diff --git a/source/extensions/common/aws/BUILD b/source/extensions/common/aws/BUILD
index 30efe81fc3..f71a587f67 100644
--- a/source/extensions/common/aws/BUILD
+++ b/source/extensions/common/aws/BUILD
@@ -77,6 +77,7 @@ envoy_cc_library(
     ],
     deps = [
         "//envoy/common:pure_lib",
+        "//envoy/common:time_interface",
         "//source/common/common:cleanup_lib",
         "//source/common/common:lock_guard_lib",
         "//source/common/common:thread_lib",
diff --git a/source/extensions/dynamic_modules/BUILD b/source/extensions/dynamic_modules/BUILD
index dc0b799a35..41fe2ca7dd 100644
--- a/source/extensions/dynamic_modules/BUILD
+++ b/source/extensions/dynamic_modules/BUILD
@@ -4,7 +4,7 @@ load(
     "envoy_extension_package",
 )
 
-licenses(["notice"])  # Apache 2
+licenses(["notice"])  # Apache 2 CACHE6
 
 envoy_extension_package()
 
@@ -18,7 +18,10 @@ envoy_cc_library(
     deps = [
         ":abi_version_lib",
         "//envoy/common:exception_lib",
-    ],
+    ] + select({
+        "//bazel:windows_x86_64": ["@dlfcn-win32//:dlfcn-win32"],
+        "//conditions:default": [],
+    }),
 )
 
 envoy_cc_library(
@@ -27,3 +30,12 @@ envoy_cc_library(
         "abi_version.h",
     ],
 )
+
+genrule(
+    name = "dynamic_modules_exports",
+    srcs = ["abi.h"],
+    outs = ["dynamic_modules_exports.def"],
+    cmd = "$(location //tools:gen_dynamic_modules_def) $(location abi.h) $@",
+    tools = ["//tools:gen_dynamic_modules_def"],
+    visibility = ["//visibility:public"],
+)
diff --git a/source/extensions/dynamic_modules/dynamic_modules.cc b/source/extensions/dynamic_modules/dynamic_modules.cc
index f07d6a23b1..5a6f46e183 100644
--- a/source/extensions/dynamic_modules/dynamic_modules.cc
+++ b/source/extensions/dynamic_modules/dynamic_modules.cc
@@ -1,6 +1,16 @@
 #include "source/extensions/dynamic_modules/dynamic_modules.h"
 
+#ifdef WIN32
+#include "dlfcn.h"
+#ifndef RTLD_NOLOAD
+#define RTLD_NOLOAD 0
+#endif
+#ifndef RTLD_NODELETE
+#define RTLD_NODELETE 0
+#endif
+#else // WIN32
 #include <dlfcn.h>
+#endif // WIN32
 
 #include <string>
 
@@ -23,14 +33,18 @@ newDynamicModule(const std::filesystem::path& object_file_absolute_path, const b
   // > This can be used to test if the object is already resident (dlopen() returns NULL if it
   // > is not, or the object's handle if it is resident).
   //
+  void* handle = nullptr;
+#ifndef _WIN32
   // So we can use RTLD_NOLOAD to check if the module is already loaded to avoid the duplicate call
-  // to the init function.
-  void* handle = dlopen(object_file_absolute_path.c_str(), RTLD_NOLOAD | RTLD_LAZY);
+  // to the init function. Because Windows doesn't support RTLD_NOLOAD, modules that support it
+  // will need to have idempotent init functions.
+  handle = dlopen(object_file_absolute_path.string().c_str(), RTLD_NOLOAD | RTLD_LAZY);
   if (handle != nullptr) {
     // This means the module is already loaded, and the return value is the handle of the already
     // loaded module. We don't need to call the init function again.
     return std::make_unique<DynamicModule>(handle);
   }
+#endif // _WIN32
   // RTLD_LAZY is required for not only performance but also simply to load the module, otherwise
   // dlopen results in Invalid argument.
   int mode = RTLD_LAZY;
@@ -43,10 +57,10 @@ newDynamicModule(const std::filesystem::path& object_file_absolute_path, const b
   if (do_not_close) {
     mode |= RTLD_NODELETE;
   }
-  handle = dlopen(object_file_absolute_path.c_str(), mode);
+  handle = dlopen(object_file_absolute_path.string().c_str(), mode);
   if (handle == nullptr) {
     return absl::InvalidArgumentError(absl::StrCat(
-        "Failed to load dynamic module: ", object_file_absolute_path.c_str(), " : ", dlerror()));
+        "Failed to load dynamic module: ", object_file_absolute_path.string(), " : ", dlerror()));
   }
 
   DynamicModulePtr dynamic_module = std::make_unique<DynamicModule>(handle);
@@ -62,14 +76,14 @@ newDynamicModule(const std::filesystem::path& object_file_absolute_path, const b
   const char* abi_version = (*init_function.value())();
   if (abi_version == nullptr) {
     return absl::InvalidArgumentError(
-        absl::StrCat("Failed to initialize dynamic module: ", object_file_absolute_path.c_str()));
+        absl::StrCat("Failed to initialize dynamic module: ", object_file_absolute_path.string()));
   }
   // Checks the kAbiVersion and the version of the dynamic module.
   if (absl::string_view(abi_version) != absl::string_view(kAbiVersion)) {
     return absl::InvalidArgumentError(
         absl::StrCat("ABI version mismatch: got ", abi_version, ", but expected ", kAbiVersion));
   }
-  return dynamic_module;
+  return std::move(dynamic_module);
 }
 
 absl::StatusOr<DynamicModulePtr> newDynamicModuleByName(const absl::string_view module_name,
@@ -82,7 +96,11 @@ absl::StatusOr<DynamicModulePtr> newDynamicModuleByName(const absl::string_view
                                                    " is not set"));
   }
   const std::filesystem::path file_path_absolute =
+#ifdef WIN32
+      std::filesystem::absolute(fmt::format("{}/lib{}.dll", module_search_path, module_name));
+#else
       std::filesystem::absolute(fmt::format("{}/lib{}.so", module_search_path, module_name));
+#endif
   return newDynamicModule(file_path_absolute, do_not_close, load_globally);
 }
 
diff --git a/tools/BUILD b/tools/BUILD
index 94892810c9..641883c9f5 100644
--- a/tools/BUILD
+++ b/tools/BUILD
@@ -10,6 +10,12 @@ exports_files([
     "check_repositories.sh",
 ])
 
+py_binary(
+    name = "gen_dynamic_modules_def",
+    srcs = ["gen_dynamic_modules_def.py"],
+    visibility = ["//visibility:public"],
+)
+
 py_binary(
     name = "stack_decode",
     srcs = ["stack_decode.py"],
diff --git a/tools/gen_dynamic_modules_def.py b/tools/gen_dynamic_modules_def.py
new file mode 100644
index 0000000000..a491b8d087
--- /dev/null
+++ b/tools/gen_dynamic_modules_def.py
@@ -0,0 +1,32 @@
+import re
+import sys
+
+def main():
+    if len(sys.argv) != 3:
+        print("Usage: gen_dynamic_modules_def.py <input_header> <output_def>")
+        sys.exit(1)
+
+    input_header = sys.argv[1]
+    output_def = sys.argv[2]
+
+    with open(input_header, 'r') as f:
+        content = f.read()
+
+    # Find all function declarations starting with envoy_dynamic_module_callback_
+    # We assume they look like "void envoy_dynamic_module_callback_foo(...);"
+    # The regex captures the function name.
+    # We look for the return type (void or others), whitespace, then the function name.
+    # Based on abi.h, they seem to be mostly void, but let's be generic.
+    # Example: void envoy_dynamic_module_callback_http_get_header(
+    matches = re.findall(r'\b(envoy_dynamic_module_callback_\w+)\(', content)
+
+    # Remove duplicates and sort
+    symbols = sorted(list(set(matches)))
+
+    with open(output_def, 'w') as f:
+        f.write("EXPORTS\n")
+        for symbol in symbols:
+            f.write(f"    {symbol}\n")
+
+if __name__ == "__main__":
+    main()
